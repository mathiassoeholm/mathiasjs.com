---
title: How to build an authentication service with JWT and Netlify functions
date: 2020-01-11
---

In this post I will show you how to build a mini authentication service. It's mini because we won't add things such as email confirmation, password reset and external login providers.
What we will have though is a secure email/password based _stateless_ authentication service.

By stateless I mean that we will generate a token, in our case a JSON Web Token (JWT),
which conveys all required information to authenticate a request.

We will also build a small React application that uses our authentication service. You can see a demo of
the final application [here](https://jwt-auth-example.netlify.com/).

We will use Netlify functions, which are just AWS serverless functions in disguise. Netlify has greatly
simplified the process of building an API and we'll be able to deploy our serverless functions along with our app by simply pushing to our Git repository.

Instead of just giving you step-by-step instructions, that you can follow like a mindless zombie, I want you to understand the theory behind it. If you only care about the end result, you can just fork the repository [here](https://github.com/mathiassoeholm/jwt-authentication-example), but if you want to understand what you're doing, read on.

## JSON Web Token (JWT)

We want to achieve a way of verifying that a user is who they say they are. Furthermore we want to do this without querying a database. Having the user send an email/password combination on every request won't work, because we will need to check against our database to see if the password is correct.

We also want to do it without keeping track of a session ID in memory as we are using serverless functions, which by their nature of only being alive while the request is processing, don't have persistent memory.

I want to explain how token-based authentication works, by using an analogy.

Pretend you are a server, you can make beep noises if you wish.
A stranger comes up to you and says: "Please register me, my email is alice@gmail.com and my password is 12345".
You're like: "Fine, I'll jot that down in my long list of members, but rather than checking that list every time we talk, I'd rather give you something that you can show me to prove who you are next time".
You find a piece of paper and write alice@gmail.com on it and a date to see how old the proof is. You decide that Alice is allowed to upload media, cast votes and chat so you also write that on the paper.
Your special handwriting guarantees that no one can fake a piece of paper like this, you are able to recognize a fake instantly.

Later that day, Alice asks you to upload a photo she took. Instead of a password and email, she gives you the piece of paper that you wrote earlier. It states that Alice's email is alice@gmail.com and that she is allowed to upload media. You recognize the handwriting as your own so you let Alice upload the photo.

Several months later, Alice wants to cast a vote in a poll that Bob made. But Alice lost the paper you gave her, she probably threw it out while cleaning.
You vaguely remember Alice, but you can't be sure it's her unless she shows you the paper.
Alright.. You'll have to do it the slow way. You ask Alice for her email and password, luckily she remembers this information: "alice@gmail.com, 12345".
You browse through the loooong list of members, and finally it says alice@gmail.com and the password matches. Phew, you don't want to check that list next time Alice needs to perform a simple action,
so you write a new piece of paper for her.

If only there was a way for a server to verify the authenticity of a message, to be sure that it was made by a specific entity and that is has not been tampered with. Then we can create something similar to this magical piece of paper. There is, it's called [Digital Signature](https://en.wikipedia.org/wiki/Digital_signature).

A JSON web token is just an open standard for such a piece of paper. It's a way to securely transmit information in the form of a JSON object, and it's usually signed with the algorithm HMAC, RSA or ECDSA.

The cool thing about RSA and ECDSA is that it's asymmetric, so the key used to sign is different from the key used to verify. If this is news to you, I recommend that you go watch [Computerphile's video on public key cryptography](https://www.youtube.com/watch?v=GSIDS_lvRv4).

Using public key cryptography, we can have a private key known only to our authentication service, and a public key available to anyone. Any ol' service we create will then be able to check the authenticity
of a user, without having to know the private key, hence greatly reducing the risk of losing our private key.

Here's an overview for you:

<img
  src="jwt-overview.svg"
  alt="A diagram showing the interaction between the web-app, the authentication service and other services"
/>

The diagram above was inspired by [this answer on StackOverflow](https://stackoverflow.com/questions/56147281/use-jwt-to-authenticate-separate-api-microservice)

## The web app

We will build a very simple signup/login flow in React. One of the cooler parts is that we'll create a convenient
`useAuth` hook, to get the currently authenticated user from any component. Here's are some snippets, showing how clean this hook makes our components:

```jsx
import React from "react"
import { UnauthenticatedApp } from "./UnauthenticatedApp"
import { AuthenticatedApp } from "./AuthenticatedApp"
import { useAuth } from "./providers/auth-provider"

function App() {
  const { user } = useAuth()
  return user ? <AuthenticatedApp /> : <UnauthenticatedApp />
}

export default App
```

We borrow this technique from the one and only Kent C. Dodds, check out [Kents blog post about authentication in React apps](https://kentcdodds.com/blog/authentication-in-react-applications).

This hook also provides a login, lougout and signup function. Here's how our Login component will look:

```jsx
export function Login() {
  const { login } = useAuth()

  const inputs = [
    {
      name: "email",
      type: "email",
    },
    {
      name: "password",
      type: "password",
    },
  ]

  return (
    <div>
      <Form title="Login" onSubmit={login} inputs={inputs} />
      <p>
        Don't have an account? <Link to="/signup">Sign up here</Link>
      </p>
    </div>
  )
}
```

As you can imagine, the Signup component is very similar.

## Getting started

I assume you have experience with Node. You can choose to follow along with either npm or yarn, I will be using yarn.

### Initialize the repo with create-react-app

We will bootstrap our React application with create-react-app. It's probably the fastest way to get started with a React application, and it's widely used.

All you have to do is run:

```shell
yarn create react-app amazing-jwt
```

or

```shell
npx create-react-app amazing-jwt
```

create-react-app initializes a Git repo for you. The next thing to do is to push this repository to GitHub, so we can deploy it easily on Netlify.
But make sure you DON'T create a README and DON'T select .gitignore or license.

<img
  src="github-create.png"
  alt="A screenshot of settings that should not be selected when creating the repo on GitHub"
/>

Now just add the remote and push the repo as described in your new empty repo on GitHub.

```
git remote add origin git@github.com:your-username/amazing-jwt.git
git push -u origin master
```

### Deploy to Netlify

Note that Netlify's UI might have changed since I wrote this, but the process should be similar.

Sign up on <https://www.netlify.com> if you haven't already. Then press the "New site from Git".
Now just follow Netlify's helpful instructions to connect your repository in GitHub.

Netlify has automatically detected that we're using create-react-app. It therefore knows what our build command is and what directory it outputs to.
All we have to do is press "Deploy site".

Netlify is now building your app, and a link should show when it's done. In fact, it will now build and publish the app every time you push to your Git repository. Simply amazing!

Thanks Netlify for making this so insanely easy.

### Set up Netlify functions workflow

We want to transpile our Netlify Functions, so we can use ES6 features, so we'll need an extra bit of configuration, but it's not too bad. Luckily we don't have to write any Webpack configs ðŸ˜‰

In the root of the repo, create a file called netlify.toml with the following content:

```
[build]
  functions = "built-lambda"
```

This tells netlify where to look for our functions.


## What we'll build

A stateless authentication service
Explain what stateless means
A small SPA with React
Show diagram with different services
React hooks so we can do this: show useUser example

Visit here: <https://jwt-auth-example.netlify.com/>

# About JWT

# Netlify functions

#

# Below here is just notes

# Notes from https://jwt.io/introduction/ (almost copy-pasted):

JWT is an open standard to securely transmit information between parties as a JSON object.
It's digitally signed with either HMAC (symmetric key) or RSA or ECDSA for public/private key.

It's possible to use JWT's to provide secrecy by encrypting. (my question: Why would you though when you have HTTPS?)
We will focus on signed tokens. They can verify integrity of claims contained within it.

### Usages of JSON web tokens:

Authentication: one user is logged in, each request will include the JWT. Access to routes, services and resources are permitted based on the token.
Signle Sign On uses JWT. (my question: how though?)

Information exchange: BEcause JWT's can be signed you can be sure senders are who they say they are. Signature is based on header and payoad, so
you can be sure that the content hasn't been tampered with.

### The JWT structure:

In its compact form (my questio: does it have other forms?), JWTs consist of three parts separated by dots.

header.payload.signature

Header: Typically two parts, the type of the token, which is JWT and siging algorithm, such as HMAC, SHA256 or RSA, for example:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

The json is base64 url encoded to form the first part of the JWT.

Payload: The second part is the payload, which contains the claims. Claims are statements about an entity (typically the user) and additional data.
Three types of claims: registered, public and private.

Registered claims: Predifined claims, not mandatory but reccomended to provide useful interoperable claims.
Some of them are iss (issuer), exp (expiration time), sub (subject), aud (audience) and others.
These claims are only three letters long because JWT is meant to be compact.

Public claims: Can be defined at will, but to avoid collission they should be define in
IANA JSON Web Token Registry.

Private claims: Simply created to share information between parties that agree on
using them. They are not reigstered or public. Here's an example of a payload

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

This part is also base64 URL encoded.

Note that even though the JWT is signed and can't be tampered with, the payload
is readable by anyone unless it is encrypted.

Signature: Here's how to calculate it if you use HMAC SHA256:

```javascript
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

The signature is used to verify that the message wasn't changed along the way.
If it was signed with a private key, it can verify that the sender og the JWT is who they say.

Putting it all together: The output from above can easily be passed in HTML and HTTP environments.
Here's an example JWT:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### How do JWTs work?

When the user successfully logs in, a JWT is returned. Since tokens are credentials
great care should be taken to prevent security issues. You should not keeps tokens
longer than required.

You should also not store sensitive session data in browser storage due to lack of security.
(my-question: Where should i then save the JWT?)

Whenever user wants to access a protected route or resource, the user agent
should send the JWT, typically in Authorization header using the Beare schema:

```
Authorization: Bearer <token>
```

This can be used as a stateless authorization mechanism. The server's routes will check
for a valid JWT in the Authorization header. If JWT contains the necessary data, the need
to query the database for certain operations may be reduced (not always the case).

If the token is sent in the Authorization header, Cross-Origin Resource Sharing (CORS)
won't be an issue as it doesn't use cookies (my-question: just need elobration).

Here's the typical flow:

```
Client  1 ----->  Authorization Server (Could be Auth0)
  3     <----- 2
  |
  |
  v
Your API
```

JWT.io is made by Auth0 so perhaps the blog post is biased. Need to investigate if Auth0 is a good idea.

1. Client request authorization from auth server. Can be one of different auth flows.
   Perhaps OpenID Connect.

2. Auth server returns access token to Client

3. Application uses access token to protect resource

### Why use JSON web tokens?

Less verbose
Can be passed in HTML and HTTP environments
Can use public/private key cryptography
Easy to parse JSON
Very compact compared to SAML token

# XSS Notes from https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)

X stands for cross, so this is Cross-Site Scripting.

Malicious scripts are injected into otherwise benign and trusted websites

# XSRF Notes from https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)

Also known as CSRF (Cross-Site Request Forgery).

An attack that forces an end user to execute unwanted actions
on a web application in which they're currently authenticated.

Specifically target state-changing requests, not theft of data, since
the attacker has no way to see the response to the forged request.

# Notes from https://stormpath.com/blog/token-auth-spa

### Cookie session, what came before tokens

After you login a cookie contains and ind that links you to a session maintained on the server.
This approach is fine as long as you use HTTPS only cookies that cannot be read
by JavaScript or non-secure transports. A CSRF strategy is also important.

But in a SPA, access control is still uncertain. How do you let your SPA know who
this user is and what they can access?

### How to use JWTs securely

If your tokens get stolen, all bets are off. Here are some must dos:

- Sign the JWT with a strong key that is avaialable
  ONLY to the authentication service.

- If put sensitive data in JWT it should be encrypted with JSON Web Encryption (JWE).

- Should use HTTPS otherwise man-in-the-middle attack can occur

- Should store the JWT in secure, HTTPS-only cookies. This prevents XSS.

### Token expiration

To avoid creating an access token that is valid forever, it should have an expiration.
This is the next level of defense.

The value should make sense for the application, for a bank it might be 15 minutes.

Some apps might want it to be valid forever.

It's hard to revoke a JWT in a stateless authentication check. Stormpath provide a status
field on all account objects, which tells if the account is disabled or not.

### Tokens and cookies

We should not avoid cookies in general. We should aboid non-secure, non-https cookies.

Never store access tokens in local storage, since its vulnerable to XSS attacks.
With secure cookies we achieve:

- You don't expose the token to the Javascript environment, which is vulberable to XSS.

- You don't transmit over non-https, which are prone to man-in-the-middle.

A tradeoff is that secure cookies are still vulberable to CSRF, so this should be dealt with.

Another tradeoff is that the claims info is hidden from the SPA, there's two ways around this.

#### Use the token to fetch user data

Can for example requrst `/user/current`

The endpoint should respond with information needed to build the SPA.

If the response is not successful, the user should authenticate.

#### Out-of-band information

Take advantage of the response body, when responding to a credential exchange.
When you write the access token to the secure cookie, you can also save some info
from the response body, perhaps in local storage.
This info can be the payload of the JWT, but this requires that the payload
should not contain sensitive information.

# Notes from https://stormpath.com/blog/build-secure-user-interfaces-using-jwts

# Notes from https://doubleoctopus.com/security-wiki/network-architecture/stateless-authentication/

Token-based authentication enables users to obtain a token that gives them access
to a service without using their username and password.
Becauase the token is a self-contained entity that conveys all requires information to
authenticate the request, it is often referred to as stateless authentication.

# Benefits to using JWTs

- You can verify the users identity without doing a database lookup
- Claims can specify exactly what the user is able to do, this gives fine-grained permissioning.
- It scales better if we don't need to keep track of sessions.
-

# Cons of using JWTs

- Sometimes we want a stateful session for example a shopping cart.
- Takes up a bit more space than a session cookie, and that extra space impacts every request.

# Other resources

https://stackoverflow.com/questions/56147281/use-jwt-to-authenticate-separate-api-microservice

How to generate RSA key for JWT
https://gist.github.com/ygotthilf/baa58da5c3dd1f69fae9

# TODO:

- Add blog post here when done: https://functions.netlify.com/add-tutorial
- Emphasize that in reality you should probably not use your own authentication service because...
- Write about netlify cli, and how it uses the same vars as you set in the UI
- Mention tr -d '\n' < k.key
