---
title: How to build an authentication service with JWT and Netlify functions
date: 2020-01-11
---

In this post I will show you how to build a mini authentication service. It's mini because we won't add things such as email confirmation, password reset and external login providers.
What we will have though is a secure email/password based _stateless_ authentication service.

By stateless I mean that we will generate a token, in our case a JSON Web Token (JWT),
which conveys all required information to authenticate a request.

We will also build a small React application that uses our authentication service. You can see a demo of
the final application [here](https://jwt-auth-example.netlify.com/).

We will use Netlify functions, which are just AWS serverless functions in disguise. Netlify has greatly
simplified the process of building an API and we'll be able to deploy our serverless functions along with our app by simply pushing to our Git repository.

Instead of just giving you step-by-step instructions, that you can follow like a mindless zombie, I want you to understand the theory behind it. If you only care about the end result, you can just fork the repository [here](https://github.com/mathiassoeholm/jwt-authentication-example), but if you want to understand what you're doing, read on.

## JSON Web Token (JWT)

We want to achieve a way of verifying that a user is who they say they are. Furthermore we want to do this without querying a database. Having the user send an email/password combination on every request won't work, because we will need to check against our database to see if the password is correct.

We also want to do it without keeping track of a session ID in memory as we are using serverless functions, which by their nature of only being alive while the request is processing, don't have persistent memory.

I want to explain how token-based authentication works, by using an analogy.

Pretend you are a server, you can make beep noises if you wish.
A stranger comes up to you and says: "Please register me, my email is alice@gmail.com and my password is 12345".
You're like: "Fine, I'll jot that down in my long list of members, but rather than checking that list every time we talk, I'd rather give you something that you can show me to prove who you are next time".
You find a piece of paper and write alice@gmail.com on it and a date to see how old the proof is. You decide that Alice is allowed to upload media, cast votes and chat so you also write that on the paper.
Your special handwriting guarantees that no one can fake a piece of paper like this, you are able to recognize a fake instantly.

Later that day, Alice asks you to upload a photo she took. Instead of a password and email, she gives you the piece of paper that you wrote earlier. It states that Alice's email is alice@gmail.com and that she is allowed to upload media. You recognize the handwriting as your own so you let Alice upload the photo.

Several months later, Alice wants to cast a vote in a poll that Bob made. But Alice lost the paper you gave her, she probably threw it out while cleaning.
You vaguely remember Alice, but you can't be sure it's her unless she shows you the paper.
Alright.. You'll have to do it the slow way. You ask Alice for her email and password, luckily she remembers this information: "alice@gmail.com, 12345".
You browse through the loooong list of members, and finally it says alice@gmail.com and the password matches. Phew, you don't want to check that list next time Alice needs to perform a simple action,
so you write a new piece of paper for her.

If only there was a way for a server to verify the authenticity of a message, to be sure that it was made by a specific entity and that is has not been tampered with. Then we can create something similar to this magical piece of paper. There is, it's called [Digital Signature](https://en.wikipedia.org/wiki/Digital_signature).

A JSON web token is just an open standard for such a piece of paper. It's a way to securely transmit information in the form of a JSON object, and it's usually signed with the algorithm HMAC, RSA or ECDSA.

The cool thing about RSA and ECDSA is that it's asymmetric, so the key used to sign is different from the key used to verify. If this is news to you, I recommend that you go watch [Computerphile's video on public key cryptography](https://www.youtube.com/watch?v=GSIDS_lvRv4).

Using public key cryptography, we can have a private key known only to our authentication service, and a public key available to anyone. Any ol' service we create will then be able to check the authenticity
of a user, without having to know the private key, hence greatly reducing the risk of losing our private key.

Here's an overview for you:

<img
  src="jwt-overview.svg"
  alt="A diagram showing the interaction between the web-app, the authentication service and other services"
/>

The diagram above was inspired by [this answer on StackOverflow](https://stackoverflow.com/questions/56147281/use-jwt-to-authenticate-separate-api-microservice)

## The web app

We will build a very simple signup/login flow in React. One of the cooler parts is that we'll create a convenient
`useAuth` hook, to get the currently authenticated user from any component. Here's are some snippets, showing how clean this hook makes our components:

```jsx
import React from "react"
import { UnauthenticatedApp } from "./UnauthenticatedApp"
import { AuthenticatedApp } from "./AuthenticatedApp"
import { useAuth } from "./providers/auth-provider"

function App() {
  const { user } = useAuth()
  return user ? <AuthenticatedApp /> : <UnauthenticatedApp />
}

export default App
```

We borrow this technique from the one and only Kent C. Dodds, check out [Kents blog post about authentication in React apps](https://kentcdodds.com/blog/authentication-in-react-applications).

This hook also provides a login, lougout and signup function. Here's how our Login component will look:

```jsx
export function Login() {
  const { login } = useAuth()

  const inputs = [
    {
      name: "email",
      type: "email",
    },
    {
      name: "password",
      type: "password",
    },
  ]

  return (
    <div>
      <Form title="Login" onSubmit={login} inputs={inputs} />
      <p>
        Don't have an account? <Link to="/signup">Sign up here</Link>
      </p>
    </div>
  )
}
```

As you can imagine, the Signup component is very similar.

## Getting started

I assume you have experience with Node. You can choose to follow along with either npm or yarn, I will be using yarn.

### Initialize the repo with create-react-app

We will bootstrap our React application with create-react-app. It's probably the fastest way to get started with a React application, and it's widely used.

All you have to do is run:

```shell
yarn create react-app amazing-jwt
```

or

```shell
npx create-react-app amazing-jwt
```

create-react-app initializes a Git repo for you. The next thing to do is to push this repository to GitHub, so we can deploy it easily on Netlify.
But make sure you DON'T create a README and DON'T select .gitignore or license.

<img
  src="github-create.png"
  alt="A screenshot of settings that should not be selected when creating the repo on GitHub"
/>

Now just add the remote and push the repo as described in your new empty repo on GitHub.

```
git remote add origin git@github.com:your-username/amazing-jwt.git
git push -u origin master
```

### Deploy to Netlify

Note that Netlify's UI might have changed since I wrote this, but the process should be similar.

Sign up on <https://www.netlify.com> if you haven't already. Then press the "New site from Git".
Now just follow Netlify's helpful instructions to connect your repository in GitHub.

Netlify has automatically detected that we're using create-react-app. It therefore knows what our build command is and what directory it outputs to.
All we have to do is press "Deploy site".

Netlify is now building your app, and a link should show when it's done. In fact, it will now build and publish the app every time you push to your Git repository. Simply amazing!

Thanks Netlify for making this so insanely easy.

### Set up Netlify functions workflow

Note that I use the term serverless functions and Netlify Functions interchangeably. You can say that Netlify Functions are a specific type of serverless functions.

We want to transpile our Netlify Functions, so we can use ES6 features, so we'll need an extra bit of configuration, but it's not too bad. Luckily we don't have to write any Webpack configs.

In the root of the repo, create a file called netlify.toml with the following content:

```
[build]
  functions = "built-lambda"
```

This tells Netlify where to look for our functions. We then install two dev dependencies, which we will use to transpile our functions.

```shell
yarn add netlify-lambda npm-run-all
```

[npm-run-all](https://www.npmjs.com/package/npm-run-all) is a tool to run multiple npm-scripts (scripts in our package.json) in parallel. We use it to build our client app and our functions in parallel.

[netlify-lambda](https://github.com/netlify/netlify-lambda) is a helper tool to build/transpile our serverless functions.

We need to adjust our current build script in the package.json file, so we build both our client code and the Netlify Functions. Update your package.json file,
so you have the following scripts:

```json
"build": "run-p build:**",
"build:app": "react-scripts build",
"build:lambda": "netlify-lambda build src/lambda",
```

In your src folder, create a lambda directory. This is where we will place our serverless functions.

Let's try and add a simple function, to see if it works. Add the following to src/lambda/hello.js.

```javascript
export async function handler() {
  return {
    statusCode: 200,
    headers: {
      "Content-Type": "text/plain",
    },
    body: "Hello There!",
  }
}
```

If you push your changes to GitHub, a new build will be triggered by Netlify. After pushing to GitHub, open your sites dashboard on Netlify.
When the build is done, press the Functions tab. You should see the Hello function there. If you press it, it will show you the URL, it looks something like:

`https://SOMETHING.netlify.com/.netlify/functions/hello`

It should say "Hello There!" if you open the link in your browser. Easy right? Congratulations if this was your first serverless function!

Before we start developing the serverless functions we need, we want to be able to run them locally. It sucks if we have to deploy them every time
just to test the code. Thankfully this is also very easy, with [Netlify Dev](https://www.netlify.com/products/dev) we can run their entire platform locally.

Start by installing the Netlify CLI as a global package:

```shell
yarn global add netlify-cli
```

or

```shell
npm install netlify-cli -g
```

Then run:

```shell
netlify dev
```

It should show you a message similar to:

```
┌─────────────────────────────────────────────────┐
│                                                 │
│   ◈ Server now ready on http://localhost:8888   │
│                                                 │
└─────────────────────────────────────────────────┘
```

If you open http://localhost:8888 you should see the application. Now try going to http://localhost:8888/.netlify/functions/hello. You should
see the "Hello There!" message again.

Netlify Dev just did A LOT of work for us! Try reading the output in the terminal, and you will realize how much this tool helps us.

It detects we're using create-react-app:

```
◈ Starting Netlify Dev with create-react-app
```

It detects that we're using netlify-lambda to build our functions, so it runs the build script:

```
◈ Function builder netlify-lambda detected: Running npm script build:lambda
```

It runs react-scripts start, because it knows we're using create-react-app. It even routes 404 requests to index.html, so we can do client side routing:

```
$ react-scripts start
ℹ ｢wds｣: Project is running at >your IP address<
ℹ ｢wds｣: webpack output is served from /
ℹ ｢wds｣: Content not from webpack is served from /Users/>your username</git/amazing-jwt/public
ℹ ｢wds｣: 404s will fallback to /index.html
```

It starts a server for the serverless functions, which even has hot reloading:

```
◈ Lambda server is listening on 34567
```

You will see in the output that the React app started on port 3000, so why does it say "Server now ready on http://localhost:8888" ?
Well, it actually sets up a proxy so we can send requests to the client and our serverless functions on the same port!
This is exactly how it works in production, so being able to simulate this locally is great. It means that anytime we want to
send a request from our app to a serverless function, we simply write a relative path:

```javascript
const response = await fetch(`/.netlify/functions/logout`)
```

This means we don't care what port it's running on and it saves us from some extra configuration.

## Creating the API

We will now build the authentication API using Netlify Functions. We will have three serverless methods, `/signup`, `/login` and `/logout`. Besides that we
will create a `/user` function, just to demonstrate how to create an protected endpoint.

### Signup

To get started, I'll show you the required steps as a bunch of comments. We'll then implement the code for each step.
Take a moment and carefully read each step, try to understand the purpose and why that step is necessary.

```javascript
// 1. Connect to the database and get a reference to the `users` collection
// 2. Get the email and password from the request body
// 3. Check to see if the user already exists, if so return error (409 Conflict)
// 4. Get a salted hash of the password
// 5. Insert the email and the hashed password in the `users` collection
// 6. Get the secret key, used to sign the JWT, from an environment variable
// 7. Create a JWT with the registered user and email as the payload
// 8. Serialize the JWT in a secure http-only cookie
// 9. Return the user id and a Set-Cookie header with the JWT cookie
```

#### Connecting to the database

We obviously need somewhere to store the registered users. The choice of database is rather arbitrary, since it's only a small part of this blog post
and our requirements here are very low. I chose MongoDB, since MongoDB Atlas has a free plan that can get us up and running in no time.

Go to <https://cloud.mongodb.com/> and register a new account. Press "Create a cluster" on the free plan and select the cloud provider and region of your choice.

After creating a cluster on mongoDB Atlas, press the CONNECT button. We need to whitelist what IP addresses can access the database. Because we're hosting our serverless functions
on Netlify, we don't know what IP address will be used, so we whitelist all IP addresses. Simply add `0.0.0.0/0` to the IP address whitelist.

You will also be asked to create a user for the database, I usually go with the username "admin", but feel free to add whatever credential you want.
We will use the credential in the next step, so remember it.

MongoDB will now ask you how you want to connect, choose "Application". It will show a connection string, similar to:

```
mongodb+srv://admin:<password>@cluster0-1mz6n.mongodb.net/test?retryWrites=true&w=majority
```

We will add the database password as an environment variable, such that we don't need to commit sensitive information to the repo.
In the Netlify UI, open your project and go to Settings -> Build & Deploy -> Environment.
Now add a new environment variable with the name `MONGODB_PASSWORD` and write the password as the value.

Our serverless functions will now have access to this value when running in production. But what if we want to be able to use our serverless functions locally?
Well, remember when I said that Netlify Dev runs their entire platform locally. This also includes environment variables, all we need to do is link our local git repo.

Run the following command to link your local repo with Netlify:

```shell
netlify link
```

When it asks you how you want to link the folder to a site, just choose "Use current git remote origin".
If you run `netlify dev` again after linking, you will notice the following message:

```
◈ Injected build setting env var: MONGODB_PASSWORD
```

Sidenote: While it's great that Netlify makes this so easy, in a real project we would probably have different environments for production and development.
Hence we would probably use something like [dotenv](https://www.npmjs.com/package/dotenv) to set some local environment variables with different values for development.

Next we need to use the MongoDB package from NPM to connect to the database, run:

```
yarn add mongodb
```

or

```
npm i mongodb
```

Finally we can write the code for step 1. We know that both signup and login will need to connect to the database, so let's create a helper that they can both make use of.
Add the following to a new file in src/helpers/db-helper.js

```javascript
import { MongoClient } from "mongodb"

const dbName = "jwt-authentication-example"

function createClient() {
  const client = new MongoClient(
    // REPLACE WITH YOUR CONNECTION STRING
    `mongodb+srv://your-username:${process.env.MONGODB_PASSWORD}@cluster0-abcdef.mongodb.net/test?retryWrites=true&w=majority`,
    { useNewUrlParser: true, useUnifiedTopology: true }
  )

  // We add a usersCollection function to the client object,
  // this way neither login or signup need to know the name
  // of the database or the users collection.
  client.usersCollection = () => {
    return client.db(dbName).collection("users")
  }

  return client
}

export { createClient }
```

Create a new serverless function in src/lambda/signup.js and start with the basic structure:

```javascript
export async function handler(event) {
  let errorStatusCode = 500

  try {
  } catch (err) {
    return {
      statusCode: errorStatusCode,
      body: JSON.stringify({ msg: err.message }),
    }
  } finally {
  }
}
```

We can now add the code that performs "step 1" from the comments:

```javascript
import { createClient } from "../helpers/db-helper";

export async function handler(event) {
  const dbClient = createClient()
  let errorStatusCode = 500

  try {
    // 1. Connect to the database and get a reference to the `users` collection
    await dbClient.connect()
    const users = dbClient.usersCollection()
  } catch (err) {
    ...
  } finally {
    // Remember to close the database connection
    dbClient.close()
  }
}
```

Getting the email and password from the body is pretty simple. The request body is given to us in the `event` parameter:

```javascript
// 2. Get the email and password from the request body
const { email, password } = JSON.parse(event.body)
```

We can now check if this user already exists:

```javascript
// 3. Check to see if the user already exists, if so return error (409 Conflict)
const existingUser = await users.findOne({ email })
if (existingUser !== null) {
  errorStatusCode = 409
  throw new Error(`A user already exists with the email: ${email}`)
}
```

You should never store a password in plain-text. By storing a hash of the password, We don't even know the users password. Even if the database is compromised, the attacker won't know the passwords either.
We will add a random salt, to ensure that two users with the same password will have different hashes. Otherwise you could use a rainbow table, which is essentially a way to reverse a hash function for a finite amount of known inputs.

Hashing the password with a random salt is easily done, when using the package bcrypt. Start by running:

```shell
yarn add bcryptjs
```

or

```shell
npm i bcryptjs
```

Then step 4 is just:

```javascript
import bcrypt from "bcryptjs";

...

// 4. Get a salted hash of the password
const passwordHash = await bcrypt.hash(password, 10);
```

Now we just insert the email and the hashed password in the users collection. When inserting the object, MongoDB generates a unique ID for us:

```javascript
// 5. Insert the email and the hashed password in the `users` collection
const { insertedId } = await users.insertOne({
  email,
  password: passwordHash,
})
```

Before we continue implementing the signup function, we need a key to sign the JWT. We will use a 4096bit RSA public/private key-pair.
To generate such a key, you will need ssh-keygen and openssl, which should already be install if you're on Mac or Linux.
Here's the commands to generate the key-pair (thanks to ygotthilf on [GitHub](https://gist.github.com/ygotthilf/baa58da5c3dd1f69fae9)):

```shell
ssh-keygen -t rsa -P "" -b 4096 -m PEM -f jwtRS256.key
openssl rsa -in jwtRS256.key -pubout -outform PEM -out jwtRS256.key.pub

# This is your private key
cat jwtRS256.key

# This is your public key
cat jwtRS256.key.pub
```

Remember that the private key is used to sign the JWT when we generate the token, and the public key is used to verify that the token is valid.

We now have a challenge, because we want to add the private key as an environment variable on Netlify. Environment variables on Netlify can't contain line-breaks, but our key is multiple lines.
To fix this open the private key in a text editor and remove the lines that say `-----BEGIN RSA PRIVATE KEY-----` and `-----END RSA PRIVATE KEY-----`.

Then run the following command:

```shell
tr -d '\n' < jwtRS256.key > jwtRS256-no-line-breaks.key
```

The file `jwtRS256-no-line-breaks.key` now contains your private key without the BEGIN and END markers and without any line-breaks. This is suitable to put into an environment variable.
Create a new environment variable on Netlify with name `JWT_SECRET_KEY` containing the contents of `jwtRS256-no-line-breaks.key`. We can now proceed with generating the JWT.

We will encapsulate the steps for creating the JWT cookie into a separate function, since it will also be used when the user logs in.
Create a new file src/helpers/jwt-helper.js with the following contents:

```javascript
/*
 * Generate a JWT with the user ID and email as the payload,
 * then serialize to a secure HTTP-only cookie.
 */
function createJwtCookie(userId, email) {}

export { createJwtCookie }
```

To implement this function, we need to install two dependencies. One for generating the JWT and another for serializing a cookie.

```shell
yarn add jsonwebtoken cookie
```

or

```shell
npm i jsonwebtoken cookie
```

Start by importing the dependencies and get the secret key from the environment variable:

```javascript
import jwt from "jsonwebtoken"
import cookie from "cookie"

function createJwtCookie(userId, email) {
  // 6. Get the secret key, used to sign the JWT, from an environment variable
  const secretKey = `-----BEGIN RSA PRIVATE KEY-----${"\n"}${
    process.env.JWT_SECRET_KEY
  }${"\n"}-----END RSA PRIVATE KEY-----`
}
```

It's important the we bring back the BEGIN and END markers and that they are on their own line.
Next up, we generate the JWT by calling `jwt.sign`:

```javascript
// 7. Create a JWT with the registered user and email as the payload
const token = jwt.sign({ userId, email }, secretKey, {
  algorithm: "RS256",
  expiresIn: "100 days",
})
```

We let the token expire after 100 days, it's up to you to choose how long the token should be valid. The expiration can be thought of a second line of defense.
If a users token is compromised, it's nice to know that it doesn't last forever. If you were building a banking platform, you might set the expiry to 15 minutes.
If you're building a mobile app, it might never expire.

Finally we create a cookie and return it:

```javascript
// 8. Serialize the JWT in a secure http-only cookie
const jwtCookie = cookie.serialize("jwt", token, {
  secure: true,
  httpOnly: true,
  path: "/",
})

return jwtCookie
```

The helper function we just created can now be used in our signup function:

```javascript
// 9. Return the user id and a Set-Cookie header with the JWT cookie
return {
  statusCode: 200,
  headers: {
    "Set-Cookie": createJwtCookie(insertedId, email),
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ id: insertedId, email }),
}
```

The final signup function looks like this:

```javascript
import bcrypt from "bcryptjs"
import { createClient } from "../helpers/db-helper"
import { createJwtCookie } from "../helpers/jwt-helper"

export async function handler(event) {
  const dbClient = createClient()
  let errorStatusCode = 500

  try {
    await dbClient.connect()
    const users = dbClient.usersCollection()

    const { email, password } = JSON.parse(event.body)

    const existingUser = await users.findOne({ email })
    if (existingUser !== null) {
      errorStatusCode = 409
      throw new Error(`A user already exists with the email: ${email}`)
    }

    const passwordHash = await bcrypt.hash(password, 10)

    const { insertedId } = await users.insertOne({
      email,
      password: passwordHash,
    })

    return {
      statusCode: 200,
      headers: {
        "Set-Cookie": createJwtCookie(insertedId, email),
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ id: insertedId, email }),
    }
  } catch (err) {
    return {
      statusCode: errorStatusCode,
      body: JSON.stringify({ msg: err.message }),
    }
  } finally {
    dbClient.close()
  }
}
```

## What we'll build

A stateless authentication service
Explain what stateless means
A small SPA with React
Show diagram with different services
React hooks so we can do this: show useUser example

Visit here: <https://jwt-auth-example.netlify.com/>

# About JWT

# Netlify functions

#

# Below here is just notes

# Notes from https://jwt.io/introduction/ (almost copy-pasted):

JWT is an open standard to securely transmit information between parties as a JSON object.
It's digitally signed with either HMAC (symmetric key) or RSA or ECDSA for public/private key.

It's possible to use JWT's to provide secrecy by encrypting. (my question: Why would you though when you have HTTPS?)
We will focus on signed tokens. They can verify integrity of claims contained within it.

### Usages of JSON web tokens:

Authentication: one user is logged in, each request will include the JWT. Access to routes, services and resources are permitted based on the token.
Signle Sign On uses JWT. (my question: how though?)

Information exchange: BEcause JWT's can be signed you can be sure senders are who they say they are. Signature is based on header and payoad, so
you can be sure that the content hasn't been tampered with.

### The JWT structure:

In its compact form (my questio: does it have other forms?), JWTs consist of three parts separated by dots.

header.payload.signature

Header: Typically two parts, the type of the token, which is JWT and siging algorithm, such as HMAC, SHA256 or RSA, for example:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

The json is base64 url encoded to form the first part of the JWT.

Payload: The second part is the payload, which contains the claims. Claims are statements about an entity (typically the user) and additional data.
Three types of claims: registered, public and private.

Registered claims: Predifined claims, not mandatory but reccomended to provide useful interoperable claims.
Some of them are iss (issuer), exp (expiration time), sub (subject), aud (audience) and others.
These claims are only three letters long because JWT is meant to be compact.

Public claims: Can be defined at will, but to avoid collission they should be define in
IANA JSON Web Token Registry.

Private claims: Simply created to share information between parties that agree on
using them. They are not reigstered or public. Here's an example of a payload

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

This part is also base64 URL encoded.

Note that even though the JWT is signed and can't be tampered with, the payload
is readable by anyone unless it is encrypted.

Signature: Here's how to calculate it if you use HMAC SHA256:

```javascript
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

The signature is used to verify that the message wasn't changed along the way.
If it was signed with a private key, it can verify that the sender og the JWT is who they say.

Putting it all together: The output from above can easily be passed in HTML and HTTP environments.
Here's an example JWT:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### How do JWTs work?

When the user successfully logs in, a JWT is returned. Since tokens are credentials
great care should be taken to prevent security issues. You should not keeps tokens
longer than required.

You should also not store sensitive session data in browser storage due to lack of security.
(my-question: Where should i then save the JWT?)

Whenever user wants to access a protected route or resource, the user agent
should send the JWT, typically in Authorization header using the Beare schema:

```
Authorization: Bearer <token>
```

This can be used as a stateless authorization mechanism. The server's routes will check
for a valid JWT in the Authorization header. If JWT contains the necessary data, the need
to query the database for certain operations may be reduced (not always the case).

If the token is sent in the Authorization header, Cross-Origin Resource Sharing (CORS)
won't be an issue as it doesn't use cookies (my-question: just need elobration).

Here's the typical flow:

```
Client  1 ----->  Authorization Server (Could be Auth0)
  3     <----- 2
  |
  |
  v
Your API
```

JWT.io is made by Auth0 so perhaps the blog post is biased. Need to investigate if Auth0 is a good idea.

1. Client request authorization from auth server. Can be one of different auth flows.
   Perhaps OpenID Connect.

2. Auth server returns access token to Client

3. Application uses access token to protect resource

### Why use JSON web tokens?

Less verbose
Can be passed in HTML and HTTP environments
Can use public/private key cryptography
Easy to parse JSON
Very compact compared to SAML token

# XSS Notes from https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)

X stands for cross, so this is Cross-Site Scripting.

Malicious scripts are injected into otherwise benign and trusted websites

# XSRF Notes from https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)

Also known as CSRF (Cross-Site Request Forgery).

An attack that forces an end user to execute unwanted actions
on a web application in which they're currently authenticated.

Specifically target state-changing requests, not theft of data, since
the attacker has no way to see the response to the forged request.

# Notes from https://stormpath.com/blog/token-auth-spa

### Cookie session, what came before tokens

After you login a cookie contains and ind that links you to a session maintained on the server.
This approach is fine as long as you use HTTPS only cookies that cannot be read
by JavaScript or non-secure transports. A CSRF strategy is also important.

But in a SPA, access control is still uncertain. How do you let your SPA know who
this user is and what they can access?

### How to use JWTs securely

If your tokens get stolen, all bets are off. Here are some must dos:

- Sign the JWT with a strong key that is avaialable
  ONLY to the authentication service.

- If put sensitive data in JWT it should be encrypted with JSON Web Encryption (JWE).

- Should use HTTPS otherwise man-in-the-middle attack can occur

- Should store the JWT in secure, HTTPS-only cookies. This prevents XSS.

### Token expiration

To avoid creating an access token that is valid forever, it should have an expiration.
This is the next level of defense.

The value should make sense for the application, for a bank it might be 15 minutes.

Some apps might want it to be valid forever.

It's hard to revoke a JWT in a stateless authentication check. Stormpath provide a status
field on all account objects, which tells if the account is disabled or not.

### Tokens and cookies

We should not avoid cookies in general. We should aboid non-secure, non-https cookies.

Never store access tokens in local storage, since its vulnerable to XSS attacks.
With secure cookies we achieve:

- You don't expose the token to the Javascript environment, which is vulberable to XSS.

- You don't transmit over non-https, which are prone to man-in-the-middle.

A tradeoff is that secure cookies are still vulberable to CSRF, so this should be dealt with.

Another tradeoff is that the claims info is hidden from the SPA, there's two ways around this.

#### Use the token to fetch user data

Can for example requrst `/user/current`

The endpoint should respond with information needed to build the SPA.

If the response is not successful, the user should authenticate.

#### Out-of-band information

Take advantage of the response body, when responding to a credential exchange.
When you write the access token to the secure cookie, you can also save some info
from the response body, perhaps in local storage.
This info can be the payload of the JWT, but this requires that the payload
should not contain sensitive information.

# Notes from https://stormpath.com/blog/build-secure-user-interfaces-using-jwts

# Notes from https://doubleoctopus.com/security-wiki/network-architecture/stateless-authentication/

Token-based authentication enables users to obtain a token that gives them access
to a service without using their username and password.
Becauase the token is a self-contained entity that conveys all requires information to
authenticate the request, it is often referred to as stateless authentication.

# Benefits to using JWTs

- You can verify the users identity without doing a database lookup
- Claims can specify exactly what the user is able to do, this gives fine-grained permissioning.
- It scales better if we don't need to keep track of sessions.
-

# Cons of using JWTs

- Sometimes we want a stateful session for example a shopping cart.
- Takes up a bit more space than a session cookie, and that extra space impacts every request.

# Other resources

https://stackoverflow.com/questions/56147281/use-jwt-to-authenticate-separate-api-microservice

How to generate RSA key for JWT
https://gist.github.com/ygotthilf/baa58da5c3dd1f69fae9

# TODO:

- Add blog post here when done: https://functions.netlify.com/add-tutorial
- Emphasize that in reality you should probably not use your own authentication service because...
- Write about netlify cli, and how it uses the same vars as you set in the UI
- Mention tr -d '\n' < k.key
