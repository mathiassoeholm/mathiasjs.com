# About JWT

# Netlify functions

# Below here is just notes

# Notes from https://jwt.io/introduction/ (almost copy-pasted):

JWT is an open standard to securely transmit information between parties as a JSON object.
It's digitally signed with either HMAC (symmetric key) or RSA or ECDSA for public/private key.

It's possible to use JWT's to provide secrecy by encrypting. (my question: Why would you though when you have HTTPS?)
We will focus on signed tokens. They can verify integrity of claims contained within it.

### Usages of JSON web tokens:

Authentication: one user is logged in, each request will include the JWT. Access to routes, services and resources are permitted based on the token.
Signle Sign On uses JWT. (my question: how though?)

Information exchange: BEcause JWT's can be signed you can be sure senders are who they say they are. Signature is based on header and payoad, so
you can be sure that the content hasn't been tampered with.

### The JWT structure:

In its compact form (my questio: does it have other forms?), JWTs consist of three parts separated by dots.

header.payload.signature

Header: Typically two parts, the type of the token, which is JWT and siging algorithm, such as HMAC, SHA256 or RSA, for example:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

The json is base64 url encoded to form the first part of the JWT.

Payload: The second part is the payload, which contains the claims. Claims are statements about an entity (typically the user) and additional data.
Three types of claims: registered, public and private.

Registered claims: Predifined claims, not mandatory but reccomended to provide useful interoperable claims.
Some of them are iss (issuer), exp (expiration time), sub (subject), aud (audience) and others.
These claims are only three letters long because JWT is meant to be compact.

Public claims: Can be defined at will, but to avoid collission they should be define in
IANA JSON Web Token Registry.

Private claims: Simply created to share information between parties that agree on
using them. They are not reigstered or public. Here's an example of a payload

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

This part is also base64 URL encoded.

Note that even though the JWT is signed and can't be tampered with, the payload
is readable by anyone unless it is encrypted.

Signature: Here's how to calculate it if you use HMAC SHA256:

```javascript
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

The signature is used to verify that the message wasn't changed along the way.
If it was signed with a private key, it can verify that the sender og the JWT is who they say.

Putting it all together: The output from above can easily be passed in HTML and HTTP environments.
Here's an example JWT:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### How do JWTs work?

When the user successfully logs in, a JWT is returned. Since tokens are credentials
great care should be taken to prevent security issues. You should not keeps tokens
longer than required.

You should also not store sensitive session data in browser storage due to lack of security.
(my-question: Where should i then save the JWT?)

Whenever user wants to access a protected route or resource, the user agent
should send the JWT, typically in Authorization header using the Beare schema:

```
Authorization: Bearer <token>
```

This can be used as a stateless authorization mechanism. The server's routes will check
for a valid JWT in the Authorization header. If JWT contains the necessary data, the need
to query the database for certain operations may be reduced (not always the case).

If the token is sent in the Authorization header, Cross-Origin Resource Sharing (CORS)
won't be an issue as it doesn't use cookies (my-question: just need elobration).

Here's the typical flow:

```
Client  1 ----->  Authorization Server (Could be Auth0)
  3     <----- 2
  |
  |
  v
Your API
```

JWT.io is made by Auth0 so perhaps the blog post is biased. Need to investigate if Auth0 is a good idea.

1. Client request authorization from auth server. Can be one of different auth flows.
   Perhaps OpenID Connect.

2. Auth server returns access token to Client

3. Application uses access token to protect resource

### Why use JSON web tokens?

Less verbose
Can be passed in HTML and HTTP environments
Can use public/private key cryptography
Easy to parse JSON
Very compact compared to SAML token

# XSS Notes from https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)

X stands for cross, so this is Cross-Site Scripting.

Malicious scripts are injected into otherwise benign and trusted websites

# XSRF Notes from https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)

Also known as CSRF (Cross-Site Request Forgery).

An attack that forces an end user to execute unwanted actions
on a web application in which they're currently authenticated.

Specifically target state-changing requests, not theft of data, since
the attacker has no way to see the response to the forged request.

# Notes from https://stormpath.com/blog/token-auth-spa

### Cookie session, what came before tokens

After you login a cookie contains and ind that links you to a session maintained on the server.
This approach is fine as long as you use HTTPS only cookies that cannot be read
by JavaScript or non-secure transports. A CSRF strategy is also important.

But in a SPA, access control is still uncertain. How do you let your SPA know who
this user is and what they can access?

### How to use JWTs securely

If your tokens get stolen, all bets are off. Here are some must dos:

- Sign the JWT with a strong key that is avaialable
  ONLY to the authentication service.

- If put sensitive data in JWT it should be encrypted with JSON Web Encryption (JWE).

- Should use HTTPS otherwise man-in-the-middle attack can occur

- Should store the JWT in secure, HTTPS-only cookies. This prevents XSS.

### Token expiration

To avoid creating an access token that is valid forever, it should have an expiration.
This is the next level of defense.

The value should make sense for the application, for a bank it might be 15 minutes.

Some apps might want it to be valid forever.

It's hard to revoke a JWT in a stateless authentication check. Stormpath provide a status
field on all account objects, which tells if the account is disabled or not.

### Tokens and cookies

We should not avoid cookies in general. We should aboid non-secure, non-https cookies.

Never store access tokens in local storage, since its vulnerable to XSS attacks.
With secure cookies we achieve:

- You don't expose the token to the Javascript environment, which is vulberable to XSS.

- You don't transmit over non-https, which are prone to man-in-the-middle.

A tradeoff is that secure cookies are still vulberable to CSRF, so this should be dealt with.

Another tradeoff is that the claims info is hidden from the SPA, there's two ways around this.

#### Use the token to fetch user data

Can for example requrst `/user/current`

The endpoint should respond with information needed to build the SPA.

If the response is not successful, the user should authenticate.

#### Out-of-band information

Take advantage of the response body, when responding to a credential exchange.
When you write the access token to the secure cookie, you can also save some info
from the response body, perhaps in local storage.
This info can be the payload of the JWT, but this requires that the payload
should not contain sensitive information.

# Notes from https://stormpath.com/blog/build-secure-user-interfaces-using-jwts

# Notes from https://doubleoctopus.com/security-wiki/network-architecture/stateless-authentication/

Token-based authentication enables users to obtain a token that gives them access
to a service without using their username and password.
Becauase the token is a self-contained entity that conveys all requires information to
authenticate the request, it is often referred to as stateless authentication.

# Benefits to using JWTs

- You can verify the users identity without doing a database lookup
- Claims can specify exactly what the user is able to do, this gives fine-grained permissioning.
- It scales better if we don't need to keep track of sessions.
-

# Cons of using JWTs

- Sometimes we want a stateful session for example a shopping cart.
- Takes up a bit more space than a session cookie, and that extra space impacts every request.

# Other resources

https://stackoverflow.com/questions/56147281/use-jwt-to-authenticate-separate-api-microservice

How to generate RSA key for JWT
https://gist.github.com/ygotthilf/baa58da5c3dd1f69fae9

# TODO:

- Add blog post here when done: https://functions.netlify.com/add-tutorial
- Emphasize that in reality you should probably not use your own authentication service because...
- Use npm instead of yarn, since it's standard



Reason we can't save user locally.
What if the JWT is expired? The user won't find out until they perform an action that requires auth,
in which case they will just be logged out randomly.